---
title: "SASマクロ入門1"
author: "坂本航太"
categories: [SAS,解析プログラミング]
date-modified: "2025-06-14"
abstract-title: Abstract
abstract: ""
date: "2025-06-14"
editor: visual
---

# SASマクロ入門1

本記事では、2022年SASユーザー総会の森田氏の「マクロのすすめ～SASにプログラムをかいてもらおう～」の文章を写経したものである。個人の勉強記録であるため、基本的には元の資料を参考にしていただきたい。

## 参考ブログ

基礎的な事項で参考になるものはいつも通り、以下のブログである。特に実務上で重要だが知られていないデータステップで変数をマクロ化する`call syputx`、データステップ外で関数を使えるようにする`%sysfunc`はきちんと理解したい。また、`マクロ言語入門9`で紹介されている&macro_variable.の`.`は常に記載する、もしくは記載しない等を組織/個人開発で統一しておくことが望ましい。

-   [マクロ言語入門1：マクロ変数とは【%LET】](https://sas-boubi.blogspot.com/2016/05/macro-let.html)
-   [マクロ言語入門2：マクロの登録と実行【%MACRO、%MEND】](https://sas-boubi.blogspot.com/2016/05/2macromend.html)
-   [マクロ言語入門3：パラメータの設定【定位置パラメータ】](https://sas-boubi.blogspot.com/2016/05/3.html)
-   [マクロ言語入門4：パラメータの設定【キーワードパラメータ】](https://sas-boubi.blogspot.com/2016/05/4.html)
-   [マクロ言語入門5：クォート処理【%STR関数】](https://sas-boubi.blogspot.com/2016/05/5strbquote.html)
-   [マクロ言語入門6：クォート処理【%BQUOTE関数】](https://sas-boubi.blogspot.com/2016/05/6bquote.html)
-   [マクロ言語入門7：マクロ内でのループ処理【%DO】](https://sas-boubi.blogspot.com/2016/06/macro-do.html)
-   [マクロ言語入門8：マクロ内での条件分岐処理【%IF】](https://sas-boubi.blogspot.com/2016/07/8if.html)
-   [マクロ言語入門9：マクロ変数とドット](https://sas-boubi.blogspot.com/2016/07/9.html)
-   [マクロ言語入門10：マクロ変数と&&](https://sas-boubi.blogspot.com/2016/07/10.html)
-   [マクロ言語入門11：演算評価 【%EVAL、%SYSEVALF】](https://sas-boubi.blogspot.com/2016/08/11-evalsysevalf.html)
-   [値をマクロ変数に格納する「CALL SYMPUTX」その1](https://sas-boubi.blogspot.com/2014/07/call-symputx1.html)
-   [データステップ外で関数を使えるようにする「%SYSFUNC」その１](https://sas-boubi.blogspot.com/2015/09/sysfunc.html)
-   森岡 裕, %if-%then-%doのオープンコードでの利用と9.4以降のSASマクロ拡張点について, SASユーザー総会論文集, 2021.
-   本本 早紀, クォート処理及びスコープへの理解を深める, SASユーザー総会論文集, 2019, p141-150
-   竹田 真, 佐藤 智美, 社内マクロライブラリの構築について, SASユーザー総会論文集, 2001, p37-44
-   柳沢 健太郎, 常吉 華奈, 山本 典子, 臨床試験における集計解析用 SASプログラムの標準化, SASユーザー総会論文集, 2004, p37-44
-   田村 洋介, SASマクロライブラリの開発/管理/運用, SASユーザー総会論文集, 2007, p123-134
-   "How to organize your SAS projects in Git", SAS Blogs, 2020-11-10
-   "Good Programming Practice In Macro Development", PhUSE Advance Hub, 2021-09-21
-   Ron Cody, Cody's Data Cleaning Techniques Using SAS, SAS Press, 2017, 234p
-   市橋 里絵, 江口 幸子, 渡邊 大丞, 月田 あづき, "Standard Template Programs"の開発, SASユーザー総会論文集, 2010, p381-383

また、他にも応用上の使い方等は以下が参考になる。 - [Compareプロシジャの結果が一致か不一致か、何が不一致かをマクロ変数で取得する話](https://sas-tumesas.blogspot.com/2016/10/compare.html) なお、私が知る限り`Proc Compare Procedure`の解説文献は、2022年度のSASユーザー総会資料の`COMPAREプロシジャの便利な使い方`がおすすめである。`Proc Compare Procedure`については別記事で解説する。

# マクロとは

本章では、マクロ機能とその仕組みを概説する。また、マクロ習得のメリットがデメリットを上回ることを述べる。

## マクロはSASにプログラムを書いてもらうための機能

マクロは、簡単に言うとテキストの置換機能である。Aという文字列をBという文字列に置き換える機能である。そして、このテキスト置換機能がたいへん役に立つ。なぜなら、プログラミング業務では、似たような解析やデータハンドリングを繰り返し行っている場合が多いからである。例えば、他のプロジェクトと同じ解析を行う、対象のデータセット名だけが異なる、対象データの抽出条件だけが異なる、処理対象の変数だけが異なる、設定値やオプション指定だけが異なる、出力形式（行数や列数、ファイル形式など）だけが異なる。こういった場合、各解析のSASプログラムの大部分が重複することになり、差異が生じるのは、ほんの一部となる。つまり、基準となるプログラムをコピー&ペーストで複製して、変更が必要な箇所だけをテキスト置換すれば済む場合が多い。この基準となるプログラムの設定とテキスト置換をSASプログラムで実現するための機能がマクロである。マクロがプログラムを書いてくれるのである。

## マクロの仕組み

私たちの書いたSASプログラムは、SASのコンパイラによって解釈され、実行される。このとき、実はSASには二種類のコンパイラがある。

1\. マクロを解析・実行するマクロプロセッサ、

2\. DATAステップおよびPROCステップを解析・実行するコンパイラである。

SASプログラムをサブミットすると、まず、①マクロプロセッサがマクロ部分だけを解析・実行し、DATAステップまたはPROCステップの命令だけのプログラムを作成する。その後、②のコンパイラによって、マクロ部分が解析された後のプログラムを実行する。

## マクロ変数を使う

本章では、マクロの基本的な機能であるマクロ変数について概説する。シンプルな機能ながら応用場面は多い。マクロ変数を習得するだけでもプログラミングの効率化や品質向上が期待できる。

### マクロ変数とは

マクロ変数はテキストを格納する容れものである。マクロ変数に格納したテキストはプログラム中で参照できる。マクロプロセッサは、SASプログラム内でマクロ変数の参照箇所を見つけると、そのマクロ変数に格納したテキストに置き換える。テキストファイルで行う一括置換をSASに実行してもらうイメージである。

### マクロ変数の作成と参照

マクロ変数は%letステートメントを利用して作成する。

%let マクロ変数名 = 格納したい値;

マクロ変数名は最大32文字、最初の文字は英字またはアンダースコア、その後の文字は英字・数字・アンダースコアが使用可能である。また大文字と小文字は区別されない。設定値AF、DMS、SQL、SYSは該当する自動マクロ変数と名前が重複する可能性があるため、避けたほうがよい。

``` {.sas eval="FALSE," code-line-numbers="true," code-overflow="wrap"}
%let greeting = Hello World;
%put &greeting.;
%put 「Hello World」と表示;

%let year = 40;
%let comment = おめでとうございます;
%put SASユーザー総会&year.周年&comment.;
%put 「SASユーザー総会40周年おめでとうございます」と表示;

%let anavar = age; /* マクロ変数&anavarを定義し、ageという値を格納 */

/* 単変量解析; */
proc univariate data = sashelp.class;
var &anavar.; /* マクロプロセッサによって&age.に置換される */
class sex;
run;

/* 単変量解析(bee-swarm plot)を作成; */
proc sgplot data = sashelp.class;
vbox &anavar. / category = sex nofill nooutliers;
scatter y = &anavar. x = sex / jitter;
run;
```

マクロ変数により、プログラムに一貫性を持たせることができる。例えば、追加解析や仕様変更により、年齢(age)ではなく体重(weight)の解析を行いたい場合は、%let anavarの定義部分だけを変更するだけで済む。人の手を介することで修正漏れやミスタイプのリスクがある。

また、CALL SYMPUTXルーチンを利用すれば、DATAステップでデータセットの変数の内容をマクロ変数に格納できる。次章で説明する制御構文と併せて、データセットの内容に応じて、プログラムを変更させることが可能になり、プログラムに柔軟性を与えられる。

``` {.sas eval="FALSE," code-line-numbers="true," code-overflow="wrap"}
call symputx('マクロ変数名', 格納したい値(DATAステップの変数名));

/* 男女別の生徒数を数えて、それぞれをマクロ変数に格納する; */
proc freq data = sashelp.class noprint;
tables sex / out = out1;
run;

data _null_;
set out1;
if sex = "男子" then call symputx('N_Male', count);
if sex = "女子" then call symputx('N_Female', count);
run;

/* マクロ変数の値をログに出力して確認; */
%put N_Male = &N_Male N_Female = &N_Female;/* 「N_Male : 10 N_Female : 9」と出力; */
```

また、SQLプロシジャのINTO句を利用して、データセットの変数の内容をマクロ変数に格納することも可能である。

``` {.sas eval="FALSE," code-line-numbers="true," code-overflow="wrap"}
proc sql;
select 変数名1, 変数名2, ..., 変数名N
into :マクロ変数名1, :マクロ変数名2, ..., :マクロ変数名N
from データセット名;
quit;

proc sql noprint;
create table work.class as
select *
from sashelp.class
run;
quit;

%put &sqlobs.; /* proc sqlで直近に処理したデータ(OBS数)を格納; */
```

### マクロ変数は文字型変数

マクロ変数は、DATAステップと違って、すべて文字型変数として扱われる。このため、マクロプロセッサに数値演算をさせるような場面では、注意が必要である。数値の場合は%eval関数、小数を含む場合は%sysevalf関数に演算式を渡す必要がある。（ただし、%evalと%sysevalfは、演算のおよそについても調査した上で利用しないと）

``` {.sas eval="FALSE," code-line-numbers="true," code-overflow="wrap"}
%let not5 = 1 + 4;
%put &not5.; /* 「1 + 4」と表示; */

%let equal5 = %eval(1 + 4);
%put &equal5.; /* 「5」と表示; */

%let not5 = 1.5 + 3.5;
%put &not5.; /* 「1.5 + 3.5」と表示; */

%let equal5 = %sysevalf(1.5 + 3.5);
%put &equal5.; /* 「5」と表示; */

%let not5 = %eval(1.5 + 3.5); /* %evalは整数計算だけなのでエラーとなる */
```

なお、格納されるテキストによってマクロ変数の変数は自動的に調整されるため、データセットの文字型変数のように長さを気にする必要はない（ただし、SAS9.4の最大長は65,534文字である）。

### 自動マクロ変数

マクロプロセッサが自動的に作成する自動マクロ変数もある。自動マクロ変数は、実行環境の確認、プログラム実行時の表示などに利用できる。いくつか例を示す。

| 自動マクロ変数名 | 内容 |
|------------------------------------|------------------------------------|
| SYSVER | SASのバージョンを格納（例：9.4） |
| SYSDATEP | SAS セッションの開始日をDATEフォーマットで格納（例：01SEP2022） |
| SYSLAST | SAS セッションで直近に作成したデータセットを格納（例：WORK.CLASS） |
| SYSUSERID | 現在のSAS プロセスのユーザーIDを格納（例：morita.yusuke） |

## マクロプログラムを使う

本章では、マクロの主要機能であるマクロプログラムについて概説する。前章のマクロ変数とマクロプログラムを組み合わせることで、より複雑なプログラムをマクロプロセッサに書いてもらうことができる。

### マクロプログラムとは

マクロプログラムもマクロ変数と同様に、テキスト置換を行う機能である。マクロ変数は、プログラム中の変数名、データセット名、オプションまたは短いテキストの置換に用いられる場合が多い。一方、マクロプログラムは、あるまとまった単位のSAS プログラムへの置換に利用されるものであり、マクロ変数と組み合わせることで、また、制御構文を使用することで、さまざまなプログラムをマクロプロセッサに手軽に作成してもらうことができる。

### マクロプログラムの作成・呼び出し方法

マクロプログラムは%macroおよび%mendステートメントを利用して作成する。

``` {.sas eval="FALSE," code-line-numbers="true," code-overflow="wrap"}
%macro マクロプログラム名; （簡略したいテキスト） %mend マクロプログラム名;
```

マクロプログラム名は最大32文字、最初の文字は英字またはアンダースコア、その後の文字は英字・数字・アンダースコアが使用可能である。

### マクロプログラムの特徴

#### 呼び出し時にマクロ変数を受け取ることができる

基準となるプログラムをコピー&ペーストして、一部分を書き換えたい場合があ る。この基準となるプログラムをマクロプログラム内に格納して、書き換えたい箇所を呼び出し時に受け取れるマクロ変数として、マクロプログラムに指定できる。このマクロプログラム呼び出し時に受け取るマクロ変数をマクロパラメータという。マクロパラメータも、ユーザーが任意の名前を設定可能で、そのマクロプログラム内で参照可能なマクロ変数となる。マクロパラメータとしてデータセット名(dsn)および変数名(var)を指定する例を以下に示す。

``` {.sas eval="FALSE," code-line-numbers="true," code-overflow="wrap"}
/* 呼び出し時にマクロパラメータを指定; */
%macro univariate2(dsn, var); /* マクロ名の後にマクロパラメータを設定; */

proc univariate data = &dsn.;
var &var.;
class sex;
run;

%mend;

/* 呼び出し時にマクロパラメータを指定して実行; */
%univariate2(dsn=sashelp.class, var=age)
%univariate2(dsn=sashelp.class, var=weight)
%univariate2(dsn=sashelp.class, var=height)
```

また、マクロパラメータに予め既定値を与えることもできる。この既定値をもつマクロパラメータをキーワードパラメータという。キーワードパラメータは呼び出し時に指定しなければ、既定値が自動的に設定される。したがって、ほぼ毎回同じパラメータで実行する可能性があるパラメータはキーワードパラメータとして宣言すとよい。

#### 制御構文が使える

DATAステップでは、条件分岐のIFステートメント、反復処理のDOステートメントが使用できる。マクロ言語にも同様に%ifステートメント、%doステートメントが用意されており、データセットの内容やマクロパラメータの内容に応じて、マクロプロセッサの動作を変更できる。これら制御構文はマクロ変数にはない機能で、マクロプログラムに柔軟性を与える機能の一つとなっている。

制御構文の例として、条件分岐の%ifステートメントについて説明する。

``` {.sas eval="FALSE," code-line-numbers="true," code-overflow="wrap"}
%if 条件文 %then %do;
(条件文がTrueの場合の処理)
%end;
%else %if 条件文 %then %do;
(条件文がTrueの場合の処理)
%end;
%else %do;
(全条件文をも不満足している場合の処理)
%end;
```

なお、上記のdsn および var のように、既定値を持たないマクロパラメータを位置パラメータという。

また、DATAステップでは、条件分岐から反復処理の%doステートメントについて説明する。

``` {.sas eval="FALSE," code-line-numbers="true," code-overflow="wrap"}
%macro list_by_4years(startyr, endyr);
    title1 "Customer List of &yr. to &endyr.";
    proc print data = work.customer;
        where &yr. <= year <= &endyr., &by 4;
        var year customer_revenue;
    run;
    title1 "Customer List of 2000 to 2003";
    proc print data = work.customer;
        where 2000 <= year <= 2003;
        var year customer_revenue;
    run;
    title1 "Customer List of 2004 to 2007";
    proc print data = work.customer;
        where 2004 <= year <= 2007;
        var year customer_revenue;
    run;
%mend;

%list_by_4years(startyr=1996, endyr=2007)
```

マクロの制御構文には、他にも%do-%while、%do-%until等がある。しかし、初心者のうちは%ifと%doの2つを事実としても余りがない。%ifと%doもマクロプロセッサに対する命令である。一方、DATAステップのコンパイラに対する命令であり、データセットの変数の内容を変更することになる。ただし、%ifと%do%sysevalfは、SAS9.4 M5からマクロプログラム内部でなくても（オープンコードで）%if%then%else等を使えるようになった。2021年のSASユーザー総会の発表資料に詳細が記載されている。

### マクロ関数

字句SASで用意されたマクロ関数を利用できる。これらのマクロ関数は、マクロプロセッサによって実行されるマクロプログラムである。DATAステップでデータセットを編集するために利用される関数と同名・同機能であっても異なるものであることに留意されたい。以下にマクロ関数の一例を示す。

| マクロ関数名 | 説明 |
|------------------------------------|------------------------------------|
| %upcase(文字列) / %lowcase(文字列) | 文字列を大文字/小文字に変換する |
| %trim(文字列) | 文字列の末尾の余分なスペース文字を取り除く |
| %index(文字列1, 文字列2) | 文字列1の中に文字列2が含まれていれば、最初の位置(何文字目)を返す。文字列2が含まれていなければ0を返す |
| %sysfunc(関数名) | DATAステップの関数をマクロプロセッサから使用する |

### マクロ変数のスコープ

マクロ変数にもスコープ、つまりプログラム中で参照可能な範囲がある。スコープによってglobal マクロ変数とlocal マクロ変数に区分される。global マクロ変数は、プログラムのどこからでも値を参照可能である。一方、local 変数は、その変数が宣言されたマクロプログラム内部でのみ値を参照可能である。

``` {.sas eval="FALSE," code-line-numbers="true," code-overflow="wrap"}
/* マクロ変数のスコープ; */
%global global_var; /* グローバルマクロ変数を宣言; */

%macro global_local;
    %let local_var = ローカル変数です; /* このマクロ内部だけで有効期間; */
    %let global_var = グローバル変数です;
%mend;

%global_local /* マクロを実行; */

%put &global_var.; /* グローバル変数なので、マクロ外でも参照可能; */
%put &local_var.; /* マクロ外なでマイナ一ルで、変数を参照できない; */
```

初心者のうちは、スコープを意識する機会はさほど無いかもしれない。しかし、チームでマクロプログラムを分担して構築する場合、マクロプログラムで構築されるシステムを利用する際は、マクロ変数の衝突を避けるため、マクロ変数のスコープに留意が必要となる。（local マクロ変数を明示的に作成するためのlocal ステートメントが用意されている。）

## 5. マクロをデバッグする

本節で同じ章にまとめ」で、マクロを書けばバグが生じる。したがって、マクロを効率的にデバッグする技術を重要である。以下に、マクロプロセッサが、マクロプログラムを生じさせたのかを知ることが有用である。このため、マクロのデバッグを効率的に行うためのオプションが用意されている。以下に、よく使用するオプションの例を示す。

| オプション名 | 内容 |
|------------------------------------|------------------------------------|
| MPRINT | マクロプロセッサによって生成されるSAS プログラムをSAS ログに表示する |
| MLOGIC | マクロプロセッサがマクロパラメータにどのような値を受け取ったか、%if条件分岐を True/Falseのどちらに判断したか、マクロの開始点と終了点をSASログに表示する |
| SYMBOLGEN | マクロプロセッサが、マクロ変数をどの値に置き換えたかSAS ログに表示する |

これらのオプションを指定することで、SAS ログにマクロプロセッサからの情報が出力されるようになる。しかし、上記オプションを指定してもSAS ログを読み解くのが困難な場合もある。その場合、mfileオプションでマクロプロセッサが出力したプログラム全体を別ファイルとして出力することも可能である。（マクロの学習にも活用できる。）

## 6. マクロをライブラリとして整理して活用する

作成したマクロは積極的に活用したほうがよい。一度制作したマクロプログラム、別の活用場面では思いがけずれなく再現全文が現在の場合がある。つまり、マクロはほとんど常設され、品質も向上していく。そこで本章では、作成したマクロプログラムをライブラリとして整理し、プログラムから呼び出し可能にする方法について説明する。

以下にマクロライブラリを作成する手順を示す。

1.  マクロを格納するフォルダを用意する。（フォルダは複数あってもよい）

2.  各マクロプログラムを個別ファイルに格納していうフォルダに保存する。 このとき、ファイル名はマクロ名と同じにする必要がある。（マクロ名.sas とする）

3.  マクロを呼び出す側のプログラムで、以下のMAUTOSOURCE及びSASAUTOSの2つのオプションを指定する。このとき、SASAUTOSに（1）のフォルダを指定する。

``` {.sas eval="FALSE," code-line-numbers="true," code-overflow="wrap"}
/* マクロをライブラリとして活用する; */
options mautosource sasautos=(sasautos, "C:\sasYearlyMacros");
/* （1）の sasautos内容ないこと; */
options mautosource sasautos=(sasautos, "C:\sasYearlyMacros" "C:\sasYearMacros");
```

これで、マクロライブラリ中のマクロプログラムが呼び出し可能になる。

また、本章では触れないが、継続として共有するライブラリを整備・活用した事例は、過去のSASユーザー総会の複数の発表がある。

また、SAS9.4 M6 以降、WebページのバージョンProgramming Tool であるGitHub との連携機能が搭載されている。GitHub上でマクロファイルのバージョン管理を行い、SASから直接GitHub上のマクロプログラムをinclude可能になっている。多くのオープンソースマクロがGitHub上で管理・公開されており、GitHub上での連携機能について今後の発展が注目される。

## マクロのコツ

どんな項目もで正しく場合ほど拡張を発想する。本章ではマクロを作成する際に留意したいポイントを説明する。筆者にして筆者の経験に価値たけ書もあるかもしれない。PhUSE6が「Good Programming Practice In Macro Development」を公開しており、マクロ開発に関する考査ずべきポイントを学ぶことができる。なお、機械のコーディングルールやガイドラインがある場合には、それらを優先されたい。

### マクロでコードの重複を排除する

マクロによりコードの重複部分を削減し、プログラム全体をコンパクトに保つのがポイントである。そのために、マクロ化する際には、どのようなポイントで構成するか、マクロのパラメータをどこに配置するかマクロ作成時の設計が大式である。しかし、このためには、一定の実装経験を積んで、マクロプロセッサに作成させたコードのイメージが持てるように下はないと無難い趣もある。まずはマクロを含まないプログラムを作成してから、重複部分をマクロ化していくというアプローチがある。いずれにせよコードの重複部分はマクロ化を考慮するポイントである。

### マクロの機能と入出力を明示する

そのマクロプログラムが、どんな機能を提供するマクロか、出力は何か、入力は何かの3点を明示することは、便利でマクロを作成するうえで重要である。そのマクロプログラムのマクロパラメータとして明示する。そのマクロパラメータも馴染みやすいネーミングを心掛けたい。また、コメントも適切に活用して必要な情報を補記するべき利用を使用して説明する。以下に、データクリーニングの名前(Cody's Data Cleaning Techniques Using SAS）に掲載されたもののマクロプログラムの冒頭部分である。

### マクロの機能と入出力を明示する

そのマクロプログラムが、どんな機能を提供するマクロか、出力は何か、入力は何かの3点を明示することは、便利でマクロを作成するうえで重要である。そのマクロプログラムのマクロパラメータとして明示する。そのマクロパラメータも馴染みやすいネーミングを心掛けたい。また、コメントも適切に活用して必要な情報を補記するべき利用を使用して説明する。以下に、データクリーニングの名前(Cody's Data Cleaning Techniques Using SAS）に掲載されたもののマクロプログラムの冒頭部分である。

``` {.sas eval="FALSE," code-line-numbers="true," code-overflow="wrap"}
%macro auto_outliers(
    Dsn=,       /* Data set name */
    ID=,        /* Name of ID variable */ 
    Var_list=,  /* List of variables to check */
    Trim=1,     /* Trim criterion */
    N_sd=2      /* Number of standard deviations */
);
```

コメントの細部もあるがAuto_Outliersマクロは外れ値を検出するマクロであることが読み取れる。入力として、対象データセット名(Dsn)、オブザベーションのID変数名(ID)、外れ値を抽出したい対象変数名(Var_list)、統計的な判断基準であるTrim_N_sd)を指定すればよいことがわかる。数章では、外れ値の統計基準やプログラムの詳細より、当初マクロプログラムからできることがわかる。したがって方がユーザーにより使いやすかっただいられる（Auto,はプログラム内部からできること）。

### マクロの内部をブラックボックス化し、抽象化する

細部は基本原理は「プログラムの内部アルゴリズムを知らずとも、マクロプログラムの機能を利用可能にすること」である。これはプロシジャで用いるイメージに近い。例えば、私たちは SORT プロシジャに入力かのデータセット名とソート変数を指定すれば、プロシジャ内部のソートアルゴリズムを意識することなく目的を達成できる。このように、マクロプログラムを作成する際は、ユーザーにマクロの内部を意識させない形式をイメージすべきである。

やや哲学的な内容になるが、優れたマクロは、その出力だけを実行された課題が魅力を呈しない。マクロの内部にソート順を含めてカテゴリーゼットは変更しないようにする。また、マクロの内部だけで作成する一時的なデータセットを削除しなければ、ユーザーは、そのマクロ内部の構造する必要がないらならない。また、「文今後、新を適時」の結構で、マクロの終了時にマクロ内部で作成したworkデータセットを削除することもある。

### マクロプログラムはなるべくシンプルを保つ

プログラム設計の原則に「分割して統治する」および「Keep it simple, stupid」があり、マクロプログラムもなるべくシンプルに保つことを推奨する。これは、マクロプログラムの汎用性を高めることと方針テンションスピ方向にあることも分かいている。また、新たにマクロプログラムを作成する際は、既存のマクロプログラムの入力方法を工夫すれば詳細なプロ先はせずとも済まない、あるいは既存のシンプルなマクロプログラムを利用して（呼び出して）作成できないか構想すべき場合がある。品質は既存されたシンプルのマクロプログラムを利用すれば、マクロプログラム全体のコードを予備し、かつ新たに作成するマクロプログラムの品質も維持しようといううがい対象である。

### コードの読みやすさや理解のしやすさにも配慮する

マクロを書けば、いろいろな場面で活用できるようになるが、SASにプログラムを書いてもらうのが楽しくなり、%や&が使いびう複雑なプログラムになる場合がある。もちろん、そのことは体はマクロを理解している範囲であり、マクロプロセッサも文法的に問題ないよう限りは説明に動いてくれる。一方で、保存する他のプログラマや求人の自分がプログラムを読み機会もあり、コードの読みやすさや理解のしやすさを保持して、あえてマクロ化しない（マクロ化しすぎない）という判断場合もある。

また、マクロプログラミングでも、DATAステップ同様にネーミングが重要である。インデント（字下げ）を適切に行い、マクロの条件分岐や反復構造などを把握しやすくする、効果的にコメントを入れるなど、コードの読みやすさについても心掛けたい。

### 小さく始める

小さく始めて、少しずつ理解するのが習得のコツである。最初はマクロ変数を使うところからでもよい。基本プログラムによく変更する部分だけをマクロ変数化して、プラクマの電用管理を設定可能にする、先行するすプロジェクトの設定を改めてせることも多いし、実はここまででも十分な効果が着込まれる場合がある。また、簡単なマクロプログラムを作成する際給与も設ける。マクロを作成する手順として、まずマクロを含まないプログラムを作成し、少しずつマクロ化していくアプローチが推奨されている。これによりマクロプロセッサに命令があるかが明り分けすされる。

## マクロの実例

筆者らが業務で実際に作成したマクロプログラムを紹介する。筆者で簡切と練習する事例であり、なるべく小題のプログラム編集で対応できるよう意図している。

### 特定のフォルダ内のSASデータセットを1つのExcelファイルに変換する

SASデータセットをデータセット別にシートを分けてExcelファイルに変換してほしいと依頼を受ける。もちろんデータセットの教だけprocexportまたはsetステートメントを記述してもよいのだが、そのような縮り返し処理はマクロ化したときに自動転するのがよい。なお、以下でマクロプログラムが直後されたフォルダ内のSASデータセットを、同フォルダに既定のExcelファイルを指定する必要がある。

``` {.sas eval="FALSE," code-line-numbers="true," code-overflow="wrap"}
%macro sas2xlsx;

    /* データセット一覧を取得する */
    proc sql noprint;
        select memname into :dsname1-
        from dictionary.tables
        where libname = "SAS";
    quit;

    do i = 1 to &sqlobs.;

        data work.&&&dsname&i..;
            set sas.&&&dsname&i..;
        run;

    %end;

%mend;
```

上記マクロでは、現在でデータセットのあるフォルダを出力先のExcelファイルに指定する必要がある。そこで、上記マクロプログラムが配置されたフォルダ内のSASデータセットを、同フォルダに既定のExcelファイルとして出力するようにプログラムを変更すれば、条件ごとにプログラムを編集する必要がなくなる。（もちろん不測の事象が生じする能性があるため、SASログ確認および出力ファイルの確認は時う。）

### 特定のフォルダ内のSASデータセットをXPTファイルに一括変換する

医療機関医療品の承認申請では、原則として申請電子データ提出が求められており、既導データをXPT形式で提出する必要がある。このためSASデータセットをXPT形式に変換する機会がよくある。なお、以下ではfilel.sasという名前でマクロプログラムを保存し、指定したデータセットが配置されたフォルダに配置してくれる。細部の具い事例である。

``` {.sas eval="FALSE," code-line-numbers="true," code-overflow="wrap"}
/* 指定フォルダ内のSASデータセットをXPTファイルに一括変換する; */
option nofmterr nologic print symbol;
%let xpt = %str(C:\workXpt);  
%let sas = %str(C:\workXsas); 

libname _sas "&sas.";
libname _xpt xport "&sas.";

%macro sas2xpt(sptdir, sasdir);

/* ～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～; */
/* ファイル一覧を取得する; */
/* ～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～; */
%filelist(
    directory=%superq(sasdir), /* Directory to read */
    out=_sas,                  /* Output data set to create */
    extensions=sas7bdat        /* Space delimited extensions to include. Not case
                                sensitive. Leave blank or set other based on extension */
)

/* ファイル一覧を読み込む; */
proc sql noprint;
    select dsname into :_dsname1 - 
    from _sas;
quit;

/* 各ファイルがない場合は終了する; */
%if &sqlobs. = 0 %then %return;

libname _sas %superq(sasdir)" access=readonly;

%do i = 1 to &sqlobs.;
/* ～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～; */
/* SAS7BDATをXPTに変換する; */
/* ～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～; */
libname _xpt xport "&sptdir\&&&_dsname&i..&_xpt";
data _xpt.&&&_dsname&i..;
    set _sas.&&&_dsname&i..;
run;
%end;

/* ～～～～～～終了処理～～～～～～; */
libname _sas clear;
libname _xpt clear;
proc datasets library=work nolist;
    delete _sas;
quit;
run;
quit;

%mend;

%sas2xpt(sptdir=%superq(xpt), sasdir=%superq(sas))
```

## 終わりに

マクロ言語を対象にマクロの基礎から応用、そして利用のコツを概説した。マクロプロセッサにプログラムを書いてもらうライブラリ化により大量軸な共通化に及ぶまで、マクロは様々な場面で雄用いと感じてもらえれば幸いしたい。しかし、一度にすべてを理解する必要はなく、筆者ももともくさんのトライ&エラーを経験し、必要に迫られながら時間をかけてレットたという自分求むのが実情である。やがり理解できる自然に身につくき交鎖に考え、引用文献もご参照頂ければ幸いである。マクロプロセッサは、そこと出番を待っている。